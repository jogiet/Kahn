
--- RESEAUX DE KAHN ---

Projet du cours de Systèmes et Réseaux
Josselin GIET, Alexis THIBAULT




Plusieurs implémentations des réseaux de Kahn ont été réalisées :
- sequential
- pipes
- network

Les exemples sur lesquels les différentes implémentations ont été testées sont :
- example
- primes
- mandelbrot



-- IMPLEMENTATIONS --


- Version séquentielle : sequential -

Dans la version séquentielle, un seul processus lourd et un seul thread sont
utilisés. Un "process" est une fonction qui, lorsqu'on l'exécute, effectue une
étape de calcul, et renvoie soit le résultat, soit sa propre continuation.

Un exemple intéressant pour comprendre comment le principe fonctionne est la
fonction "bind". Le processus renvoyé par "bind x f", par exemple, effectue une
étape de x. Dans le cas où x renvoie un résultat, la suite est le processus
"f x". Si x renvoie une continuation y, la suite de "bind x f" est le processus
"bind y f".

De façon générale, l'exécution d'un processus consiste en une étape de
réduction. Pour chaque tâche parallèle, on effectue séquentiellement une
réduction sur chaque tâche.

Les fonctions "put" et "get" consistent simplement à lire ou écrire dans des
FIFO (type 'a channel = 'a Queue.t).


- Version processus lourds : pipes -

Dans la version pipes on utilise un processus lourd pour chaque processus
de Kahn. Ces processus sont ainsi executés en parallèle par le scheduler
de l'OS. Ainsi, quand on appel la fonction "doco" sur une liste contenant
plusieurs processus, on crée un nouveau processus lourd qui éxecute le
premier processus et on procède récursivement sur le reste de la liste.
Le cas où il n'y a un seul processus, il est exécuté dans le processus
lourd courant.

La communication entre processus se fait au moyen de pipes. Les fonctions
"put" et "get" font appel au module Marshal. 

- Version réseau : network -

Dans la version réseau, il y a principalement trois éléments différents :
* Un serveur, qui, dans une boucle infinie, communique avec les clients afin de
distribuer les tâches et transmettre les messages.
* Un nombre arbitraire de clients de travail, qui attendent des tâches.
* Le client principal, sur lequel on appelle "run".

Les trois utilisent le même code compilé, de façon à pouvoir transmettre des
fonctions par le module Marshal, mais une option permet de lancer le serveur
(-s), un client de travail (-w), ou le client principal (pas d'option).

Un canal de communication est représenté par un entier, fourni par le serveur.
La fonction "new_channel ()" fait donc un appel au serveur ; c'est pourquoi il
est nécessaire de geler l'évaluation de "main" dans Primes ou Example jusqu'à ce
que la connexion soit établie (on a transformé "main" en fonction
unit -> 'a process). Lors de l'envoi d'un message sur un canal, le client envoie
au serveur un objet Message(v,q) contenant la valeur du message et le numéro du
canal. Le serveur l'ajoute alors à la file du canal correspondant. Lorsque le
client effectue une requête Get, il envoie une demande au serveur, puis passe
le process correspondant dans un état d'attente. Un process en attente vérifie
si le serveur a transmis le message (auquel cas il doit avoir été mis dans un
buffer chez le client), et si ce n'est pas le cas, il reste en attente et
passe la main.

Une difficulté à laquelle nous avons été confrontés est le fait que lors de la
transmission de valeurs fonctionnelles par Marshal, la valeur obtenue contient
aussi la clôture. Ainsi, les buffers du client, servant à la réception de la
réponse du serveur à une requête Get, n'étaient pas les mêmes selon le contexte,
ce qui conduisait à un comportement incohérent. Il suffisait en fait de changer
buffers en variable globale (hors du module Network.N) pour résoudre ce
problème.

Sur les applications example et primes, cette méthode n'est pas très efficace.
En effet, ces deux applications utilisent les canaux de manière intensive ; or,
la communication réseau est très lente. Il lui faut donc plusieurs secondes pour
trouver une centaine de nombres premiers.



-- APPLICATIONS --


- Example -

Un réseau de Kahn minimal, où un process énumère les entiers sur un canal, et
l'autre les lit et les affiche.

- Primes -

Un réseau de Kahn issu du TP n°5, qui met en oeuvre le crible d'Eratosthene,
en créant, pour chaque nombre premier, un processus qui ne transmet que les
entiers que le nombre premier ne divise pas.

- Mandelbrot -

Un réseau de Kahn permettant d'afficher l'ensemble de Mandelbrot.

On distingue 5 types de processus :
1- le processus "input" qui crée et envoie une structure de donnée
   contenant l'abscisse et l'ordonnée du pixel en cours de calcul, le
   nombre complexe correspondant dans le plan complexe. (Remarque : on
   suppose qu'on souhaite afficher l'ensemble dans une fenêtre de
   dimension 3:2 et on translate le point 0 du plan complexe au pixel  
   (2,1) de l'image).
   À la fin, il envoie un élément "End_i".

2- Les processus "iter" lisent sur leur entrée la structure de donnée
   envoyée par "input" ou le processus "iter" précedent. Puis, ils
   itèrent un certain nombre de fois, le calcul de la suite. Si après ce
   calcul, la condition suffisante de divergence est vérifiée, alors la
   structure de donée  est
   envoyée au processus "color". Sinon, elle est envoyée modifiée  au 
   prochain processus "iter" avec la novelle valeurs de la suite et le
   nombre d'itérations "subies".
   Quand le processus "iter" recoit "End_i", alors, il le réenvoie
   à "color" et au processus "iter". 

3- Le processus "color" qui lit sur son entrée la structure de donnée et
   qui renvoie sur sa sortie le pixel avec ouleur correspondante au
   nombre d'itérations subies.
   - noir si l'élément a subi n_tot itérations,
   - une variante de vert sinon, plus la teinte est claire, plus le
	 complexe a subi d'itérations avant de vérifier la condition de
	 divergence.

4- Le processus "assemble" qui lit tous le pixels envoyés par "color" et
   qui les regroupe dans une matrice.

5- Le processus "print" qui lit sur son entrée la matrice envoyée par
	"assemble" et l'affiche au moyen du module Graphics.
	Ce processus attend que k'utilisateur presse une touche quelconque
	pour continur et renvoyer ().

Remarque : 
	L'exemple Mandelbrot lancé sur l'implémentation avec les pipes ne
	fonctionne que sur des petites valeurs. 


